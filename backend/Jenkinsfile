pipeline {
  agent any
  
  options {
    timestamps()
    disableConcurrentBuilds()
    skipDefaultCheckout(true)
  }

  parameters {
    string(name: 'AWS_REGION', defaultValue: 'us-west-2')
    string(name: 'IMAGE_TAG', defaultValue: 'latest')
    string(name: 'SSM_PATH',   defaultValue: '/russchords/stage/backend', description: 'SSM Parameter Store path')
  }

  stages {
    stage('Load env from SSM') {
      steps {
        withAWSParameterStore(path: params.SSM_PATH, recursive: true, naming: 'relative', regionName: params.AWS_REGION) {
          script {
            env.AWS_REGION        = "${params.AWS_REGION}"
            env.IMAGE_TAG         = "${params.IMAGE_TAG}"
            env.CODEBUILD_PROJECT = "${CODEBUILD_PROJECT}"
            env.AWS_ACCOUNT_ID    = "${AWS_ACCOUNT_ID}"
            env.ECR_REPO          = "${ECR_REPO}"
            env.ECS_CLUSTER       = "${ECS_CLUSTER}"
            env.ECS_SERVICE       = "${ECS_SERVICE}"
            env.ECR_IMAGE         = "${env.AWS_ACCOUNT_ID}.dkr.ecr.${env.AWS_REGION}.amazonaws.com/${env.ECR_REPO}:${env.IMAGE_TAG}"
          }
        }
      }
    }

    stage('Preflight') {
      steps {
        sh '''#!/bin/bash
set -euo pipefail

command -v aws >/dev/null 2>&1 || { echo "[err] aws cli not found"; exit 1; }
command -v jq  >/dev/null 2>&1 || { echo "[err] jq not found"; exit 1; }

: "${AWS_REGION:?AWS_REGION is required}"
: "${CODEBUILD_PROJECT:?CODEBUILD_PROJECT is required}"
: "${AWS_ACCOUNT_ID:?AWS_ACCOUNT_ID is required}"
: "${ECR_REPO:?ECR_REPO is required}"
: "${ECR_IMAGE:?ECR_IMAGE is required}"
: "${ECS_CLUSTER:?ECS_CLUSTER is required}"
: "${ECS_SERVICE:?ECS_SERVICE is required}"
'''
      }
    }

    stage('Build & Push via CodeBuild') {
      steps {
        sh '''#!/bin/bash
set -euo pipefail

echo "[info] will build/push: ${ECR_IMAGE}"

# Start CodeBuild job
START_OUT="$(aws codebuild start-build \
  --region "${AWS_REGION}" \
  --project-name "${CODEBUILD_PROJECT}" \
  --environment-variables-override \
    name=AWS_DEFAULT_REGION,value="${AWS_REGION}",type=PLAINTEXT \
    name=AWS_REGION,value="${AWS_REGION}",type=PLAINTEXT \
    name=AWS_ACCOUNT_ID,value="${AWS_ACCOUNT_ID}",type=PLAINTEXT \
    name=IMAGE_REPO_NAME,value="${ECR_REPO}",type=PLAINTEXT \
    name=ECR_REPO,value="${ECR_REPO}",type=PLAINTEXT \
    name=IMAGE_TAG,value="${IMAGE_TAG}",type=PLAINTEXT \
)"

BUILD_ID="$(echo "$START_OUT" | jq -r '.build.id')"
[ -n "$BUILD_ID" ] && [ "$BUILD_ID" != "null" ] || { echo "[err] no BUILD_ID"; exit 1; }

echo "[info] started CodeBuild: ${BUILD_ID}"

# Wait until build finishes
while :; do
  RES="$(aws codebuild batch-get-builds --ids "$BUILD_ID" --region "${AWS_REGION}")"
  
  STATUS="$(echo "$RES" | jq -r '.builds[0].buildStatus')"
  PHASE="$(echo "$RES" | jq -r '.builds[0].currentPhase')"
  
  echo "[wait] status=$STATUS phase=$PHASE"
  
  case "$STATUS" in
    SUCCEEDED) break ;;
    FAILED|FAULT|TIMED_OUT|STOPPED)
      echo "[err] CodeBuild failed with status=$STATUS"
      exit 1
      ;;
    *) sleep 5 ;;
  esac
done

echo "[ok] CodeBuild SUCCEEDED: ${BUILD_ID}"
'''
      }
    }
    
    stage('Deploy to ECS (force new deployment)') {
      steps {
        sh '''#!/bin/bash
set -euo pipefail

echo "[ecs] force new deployment for ${ECS_CLUSTER}/${ECS_SERVICE}"
aws ecs update-service \
  --cluster "${ECS_CLUSTER}" \
  --service "${ECS_SERVICE}" \
  --force-new-deployment \
  --region "${AWS_REGION}" >/dev/null

echo "[ok] ECS updated"
'''
      }
    }
  }

  post {
    failure {
      echo "Pipeline failed"
    }
    success {
      echo "Pipeline finished OK. ECR_IMAGE=${env.ECR_IMAGE}"
    }
  }
}
